# データベース設計

## 2024-01-02 - ID設計のベストプラクティス

### 質問
タスクIDは機械用だと思うからいったんはいいのかな？数字をつけるときのベストプラクティス的なものはあるのだろうか

### 回答
ID設計のベストプラクティスについて説明します。

## ID設計のベストプラクティス

### 1. 自動採番ID（AUTOINCREMENT）の特徴

#### 利点
- **シンプル**: 実装が簡単
- **見やすい**: 連番で分かりやすい
- **パフォーマンス**: インデックスが効きやすい
- **小規模アプリに最適**: タスク管理アプリなど

#### 欠点
- **予測可能**: セキュリティリスク（推測されやすい）
- **ギャップ**: 削除されたIDは再利用されない
- **分散システム**: 複数データベース間で一意性を保証できない

### 2. 用途別の選択

#### 内部ID（機械用）→ 現在の実装で問題なし
```
✅ 自動採番ID（AUTOINCREMENT）
- システム内部での識別子
- ユーザーには表示しない
- パフォーマンス重視
```

#### 公開ID（ユーザーに見せる）→ 別途考慮
```
⚠️ UUID または ランダムな文字列
- 予測不可能
- セキュリティが高い
- 複数システム間で一意性を保証
```

### 3. 代替案：UUID

#### UUIDとは
- 128ビットの一意な識別子
- 例: `550e8400-e29b-41d4-a716-446655440000`
- 予測不可能で、複数システム間で一意

#### 実装例
```python
import uuid

# UUIDを生成
task_id = str(uuid.uuid4())
# → "550e8400-e29b-41d4-a716-446655440000"
```

#### 利点
- **セキュリティ**: 予測不可能
- **一意性**: 複数データベース間で一意性を保証
- **再利用**: 削除されたIDを再利用しても問題ない

#### 欠点
- **パフォーマンス**: 文字列なので、数値IDより劣る
- **見た目**: 複雑で分かりにくい
- **ストレージ**: 容量が大きい

### 4. ハイブリッドアプローチ（推奨）

#### 内部ID + 公開ID
```python
class Task:
    id: int  # 内部ID（自動採番、機械用）
    public_id: str  # 公開ID（UUID、ユーザーに見せる）
    title: str
    ...
```

#### メリット
- **内部ID**: パフォーマンス重視
- **公開ID**: セキュリティ重視
- **両方の利点**: を活用

### 5. 現在のプロジェクトでの判断

#### タスク管理アプリの場合
- 単一ユーザー想定
- 小規模データ
- 内部IDのみで十分

#### 推奨
- **現在の実装（自動採番ID）で問題なし**
- 将来的に公開APIが必要になったら、UUIDを追加検討

## まとめ

| 方式 | 用途 | 利点 | 欠点 |
|------|------|------|------|
| **自動採番ID** | 内部ID（機械用） | シンプル、高速 | 予測可能 |
| **UUID** | 公開ID（ユーザー向け） | セキュリティが高い | パフォーマンスが劣る |
| **ハイブリッド** | 両方 | 両方の利点 | 実装が複雑 |

## ベストプラクティスのまとめ

1. **内部ID（機械用）**: 自動採番IDで問題なし ✅
2. **公開ID（ユーザー向け）**: UUIDを検討
3. **小規模アプリ**: 自動採番IDで十分
4. **大規模・公開API**: UUIDまたはハイブリッド

### 重要なポイント
- タスク管理アプリのような小規模アプリでは、自動採番IDで十分
- 内部ID（機械用）として使うなら、現在の実装で問題なし
- 将来的に公開APIが必要になったら、UUIDを追加検討

### 関連トピック
- [SQLite.md](./SQLite.md)
- [アーキテクチャ設計.md](./アーキテクチャ設計.md)

